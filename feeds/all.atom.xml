<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>knowidea</title><link href="/" rel="alternate"></link><link href="/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2019-01-25T11:30:00+09:00</updated><entry><title>RabbitMQ - #00</title><link href="/rabbitmq-00.html" rel="alternate"></link><published>2019-01-25T11:30:00+09:00</published><updated>2019-01-25T11:30:00+09:00</updated><author><name>good-paper</name></author><id>tag:None,2019-01-25:/rabbitmq-00.html</id><summary type="html">&lt;p&gt;RabbitMQ Study #00&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Prologue&lt;/h2&gt;
&lt;p&gt;여기서는 몇장의 이미지만 올립니다.&lt;/p&gt;
&lt;h2&gt;Definition&lt;/h2&gt;
&lt;p&gt;&lt;img alt="definition" src="/images/rmq_00/rmq_00_definition.png"&gt;&lt;/p&gt;
&lt;h2&gt;Exchange Type&lt;/h2&gt;
&lt;p&gt;&lt;img alt="definition" src="/images/rmq_00/rmq_00_exchange_type.png"&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html&lt;/li&gt;
&lt;/ol&gt;</content><category term="amqp"></category><category term="rabbitmq"></category></entry><entry><title>RabbitMQ - #01</title><link href="/rabbitmq-01.html" rel="alternate"></link><published>2019-01-25T11:30:00+09:00</published><updated>2019-01-25T11:30:00+09:00</updated><author><name>good-paper</name></author><id>tag:None,2019-01-25:/rabbitmq-01.html</id><summary type="html">&lt;p&gt;RabbitMQ Study #01 -&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Prologue&lt;/h2&gt;
&lt;p&gt;본 문서는 RabbitMQ 홈페이지에 나와 있는 튜토리얼 문서를 공부하는 차원에서 필요한 부분만 해석해서 요약한 문서입니다. 이 점 참고해주세요.
&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;RabbitMQ는 메시지 브로커이다. 우체국으로 생각하면 편함.
 - 우체통에 편지를 넣으면, 우체부가 수신처에 편지를 갖다줄 것이라는 확신을 할 수 있지 않은가??
여기서 우체국, 우체통, 우체부를 RabbitMQ라 할 수 있다. (있단다...)&lt;/p&gt;
&lt;p&gt;&lt;img alt="producer" src="/images/rmq_01/rmq_01_producer.png" title="PRODUCER"&gt;&lt;/p&gt;
&lt;p&gt;Producing은 메시지를 전달하는 것을 의미한다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="queue" src="/images/rmq_01/rmq_01_queue.png" title="QUEUE"&gt;&lt;/p&gt;
&lt;p&gt;Queue는 RabbitMQ 안에 들어있는 우체통과 같은 것이다. 이 큐는 RabbitMQ Server가 존재하는 Host의 리소스를 잡아먹기 때문에, Host 서버만 성능이 좋으면 된다. 송수신부의 Application들은 이 Queue에 대한 성능에 신경쓸 필요가 없다.
1개 Queue에 여러 발송자가 메시지를 던질 수 있고, 1개 Queue에 여러 수신자가 메시지를 받아갈 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;img alt="consumer" src="/images/rmq_01/rmq_01_consumer.png"&gt;&lt;/p&gt;
&lt;p&gt;Consuming은 메시지를 수신하는 것을 의미한다. (그 메세지에 대한 처리는 알아서들 하겠지...)
&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;Hello World!&lt;/h2&gt;
&lt;p&gt;여기서는 Python을 예로 사용한다. RabbitMQ를 활용하기 위한 Python의 package는 pika이다.
Tutorial로 Producer / Consumer를 각각 만들어서 테스트 해 볼 것임. 이를 도식화하면 아래와 같음.&lt;/p&gt;
&lt;p&gt;&lt;img alt="overall" src="/images/rmq_01/rmq_01_overall.png"&gt;&lt;/p&gt;
&lt;h4&gt;1. Sending&lt;/h4&gt;
&lt;p&gt;&lt;img alt="sending" src="/images/rmq_01/rmq_01_sending.png"&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pika&lt;/span&gt;

&lt;span class="c1"&gt;# connection 설정득 &amp;amp; channel 획득&lt;/span&gt;
&lt;span class="n"&gt;connection&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pika&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BlockingConnection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;pika&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ConnectionParameters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;host&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;channel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;connection&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;channel&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# Queue 선언&lt;/span&gt;
&lt;span class="n"&gt;channel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;queue_declare&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# 데이터 전송.&lt;/span&gt;
&lt;span class="c1"&gt;# RabbitMQ에서 메시지는 Queue로 바로 보낼 수 없고, Exchange를 거쳐서만 갈 수 있다. 자세한건 다음에 나오니, 우선 그렇다는 것만 알고 넘어감...&lt;/span&gt;
&lt;span class="c1"&gt;# Exchange를 공백으로 놓으면, 사용자가 지정한 Queue로 메시지를 바로 보낼수 있다. 이를 위해서 Routine key로 Queue 이름을 집어 넣는다.&lt;/span&gt;
&lt;span class="n"&gt;channel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;basic_publish&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;exchange&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;routing_key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Hello World!&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot; [x] Sent &amp;#39;Hello World!&amp;#39;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# 다 했으면, Connection 종&lt;/span&gt;
&lt;span class="n"&gt;connection&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;2. Receiving&lt;/h4&gt;
&lt;p&gt;&lt;img alt="sending" src="/images/rmq_01/rmq_01_receiving.png"&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pika&lt;/span&gt;

&lt;span class="c1"&gt;# connection 설정 및 channel 획득&lt;/span&gt;
&lt;span class="n"&gt;connection&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pika&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BlockingConnection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;pika&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ConnectionParameters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;host&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;channel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;connection&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;channel&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# Queue 선언( 위에서 선언했는데도 또 선언해도 되는가...? Queue 선언은 Idempotent 성격이 적용되기 때문에, 없으면 만들고, 있으면 그대로 있는 것을 씀.)료&lt;/span&gt;
&lt;span class="c1"&gt;# 생각해보면... 실제 환경에서는 Server / Client가 같은 서버에 있는 것도 아니고, 같은 코드를 공유하지 않을 수도 있으니... 이렇게 하면 더 편할듯.&lt;/span&gt;
&lt;span class="n"&gt;channel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;queue_declare&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;properties&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot; [x] Received &lt;/span&gt;&lt;span class="si"&gt;%r&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# 위에 정의한 함수를 callback으로 등록하고, 메시지가 오면, 위 함수가 실행됨.&lt;/span&gt;
&lt;span class="n"&gt;channel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;basic_consume&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;no_ack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; [*] Waiting for messages. To exit press CTRL+C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# 무한대 루프를 돌면서 메시지 수신을 처리한다. (나중에 종료하고 싶으면 Ctrl+c로 종료하면 된다.)&lt;/span&gt;
&lt;span class="n"&gt;channel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_consuming&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;3. Result&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;##################### send.py&lt;/span&gt;
 &lt;span class="o"&gt;[&lt;/span&gt;*&lt;span class="o"&gt;]&lt;/span&gt; Waiting &lt;span class="k"&gt;for&lt;/span&gt; messages. To &lt;span class="nb"&gt;exit&lt;/span&gt; press CTRL+C
 &lt;span class="o"&gt;[&lt;/span&gt;x&lt;span class="o"&gt;]&lt;/span&gt; Received b&lt;span class="s1"&gt;&amp;#39;Hello World!&amp;#39;&lt;/span&gt;
&lt;span class="c1"&gt;#####################&lt;/span&gt;

&lt;span class="c1"&gt;##################### receive.py&lt;/span&gt;
 &lt;span class="o"&gt;[&lt;/span&gt;x&lt;span class="o"&gt;]&lt;/span&gt; Sent &lt;span class="s1"&gt;&amp;#39;Hello World!&amp;#39;&lt;/span&gt;
&lt;span class="c1"&gt;#####################&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Next...&lt;/h2&gt;
&lt;p&gt;다음 절에서는 Queue에 Naming을 한 다음 사용하는 것을 배운다.
&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;https://www.rabbitmq.com/tutorials/tutorial-one-python.html&lt;/li&gt;
&lt;/ol&gt;</content><category term="amqp"></category><category term="rabbitmq"></category></entry><entry><title>NAT 이란?</title><link href="/about-nat.html" rel="alternate"></link><published>2019-01-08T11:30:00+09:00</published><updated>2019-01-08T11:30:00+09:00</updated><author><name>good-paper</name></author><id>tag:None,2019-01-08:/about-nat.html</id><summary type="html">&lt;p&gt;What is NAT&lt;/p&gt;</summary><content type="html">&lt;h2&gt;왜 알아보게 되었나...&lt;/h2&gt;
&lt;p&gt;AWS로 개발을 하고 있다. 여러 서비스 중 VPC를 사용하고 있는데, 이 VPC 안에는 Public IP로 접근 가능한 Instance, Private IP로 접근 가능한 Instance들로 구성이 되어 있다. Public IP(Elastic IP)가 할당된 Instance들은 바로 SSH로 접속할 수 있지만, Private IP가 할당된 Instance는 일종의 매개체를 통해서 접속해야 한다. 그래서 공유기의 Port forwarding과 같은 역할을 하는 NAT용 Instance를 만들어야 하는데, NAT에 대한 정확한 정의를 확인하고자 하여 이 글을 작성하게 되었다.&lt;/p&gt;
&lt;h2&gt;사전적 정의&lt;/h2&gt;
&lt;p&gt;NAT: Network Address Translation. 네트워크 주소 변환.
IP Packet의 포트 번호, 발송지와 목적지의 IP 주소를 재기록하여 라우터를 통해 네트워크 트래픽을 주고 받는 기술.&lt;/p&gt;
&lt;h2&gt;왜 NAT을 사용함?&lt;/h2&gt;
&lt;p&gt;사설 네트워크에 있는 여러 Host가 하나의 공인 IP를 이용하여 인터넷에 접속하기 위함. 이를 사용함으로써, 
1. 인터넷 공인 IP 주소를 절약할 수 있고,
2. 사설망에 있는 장비를 외부의 침입자로부터 보호할 수 있음.&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;http://jwprogramming.tistory.com/30&lt;/li&gt;
&lt;li&gt;http://darksoulstory.tistory.com/72&lt;/li&gt;
&lt;li&gt;https://kb.netgear.com/992/What-is-NAT-Network-Address-Translation&lt;/li&gt;
&lt;/ol&gt;</content><category term="network"></category></entry><entry><title>CentOS 7 - Rename file</title><link href="/centos7-rename-file.html" rel="alternate"></link><published>2017-10-10T19:40:00+09:00</published><updated>2017-10-10T19:40:00+09:00</updated><author><name>good-paper</name></author><id>tag:None,2017-10-10:/centos7-rename-file.html</id><summary type="html">&lt;p&gt;How rename multiple files in linux(CentOS) system?&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Circumstance&lt;/h2&gt;
&lt;p&gt;On developing SW module, I had to rename multiple files to handle requirements. Only files I had consisted with old file name conventions. So, I need to rename files in linux system. &lt;/p&gt;
&lt;h2&gt;Personal condition&lt;/h2&gt;
&lt;p&gt;I had a few knowledge about linux shell commands...&lt;/p&gt;
&lt;h2&gt;What access to solution&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;I thought to write shell script.&lt;/li&gt;
&lt;li&gt;Search keyword 'rename multiple filename' at google.&lt;/li&gt;
&lt;li&gt;I got this link. &lt;a href="https://stackoverflow.com/questions/16541582/finding-multiple-files-recursively-and-renaming-in-linux"&gt;https://stackoverflow.com/questions/16541582/finding-multiple-files-recursively-and-renaming-in-linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;I follow the solution of kamituel. &lt;a href="https://stackoverflow.com/users/782609/kamituel"&gt;https://stackoverflow.com/users/782609/kamituel&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;How I did&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ find . -type f -name &lt;span class="s1"&gt;&amp;#39;*targetExpression*&amp;#39;&lt;/span&gt; -exec rename targetExpression newExpression &lt;span class="s1"&gt;&amp;#39;{}&amp;#39;&lt;/span&gt; &lt;span class="se"&gt;\;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;.: Current directory and childrens&lt;/li&gt;
&lt;li&gt;-type f: I will find node type as file.&lt;/li&gt;
&lt;li&gt;-name expression: Files with specific expression what I want to find.&lt;/li&gt;
&lt;li&gt;-exec: Execute command to result of find command.&lt;/li&gt;
&lt;li&gt;rename: Shell command to rename file.&lt;/li&gt;
&lt;li&gt;'{}': matched result files of find command. It uses arguments for rename command.&lt;/li&gt;
&lt;li&gt;\;: Means end of the exec expression. &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</content><category term="shell"></category></entry><entry><title>The very first article.</title><link href="/the-very-first-article.html" rel="alternate"></link><published>2017-10-06T07:30:00+09:00</published><updated>2017-10-06T07:30:00+09:00</updated><author><name>good-paper</name></author><id>tag:None,2017-10-06:/the-very-first-article.html</id><summary type="html">&lt;p&gt;About this blog...&lt;/p&gt;</summary><content type="html">&lt;p&gt;This is the very first article of this blog. I will keep upload information about SW Engineering. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The person who write contents in this blog is not only a non-native english speaker but also writing contents as english. Please understand to irregular syntax.&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="pelican"></category></entry></feed>